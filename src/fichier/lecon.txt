 

# ğŸ“˜ COURS 1 â€” INTRODUCTION Ã€ `FileInputStream` (Niveau DÃ©butant)

 ğŸ¯ Objectifs du cours

Ã€ la fin de ce cours, tu sauras :
    * Ce quâ€™est un **Stream** en Java
    * Ã€ quoi sert `FileInputStream`
    * Comment lire un fichier simple
    * Pourquoi Java utilise des **octets**
 
 1ï¸âƒ£ Quâ€™est-ce quâ€™un Stream en Java ?

ğŸ“Œ DÃ©finition simple
Un Stream est un flux de donnÃ©es** qui circule :

  soit vers ton programme (Input)
  soit depuis ton programme (Output)

ğŸ’¡ Image mentale :
> Comme un tuyau dâ€™eau ğŸš° : les donnÃ©es passent goutte par goutte.



 Types de streams en Java

| Type         | Description        |
| ------------ | ------------------ |
| InputStream  | Lire des donnÃ©es   |
| OutputStream | Ã‰crire des donnÃ©es |
| Reader       | Lire du texte      |
| Writer       | Ã‰crire du texte    |

ğŸ“Œ `FileInputStream` appartient Ã  :

```java
java.io.InputStream
```

---

## 2ï¸âƒ£ Ã€ quoi sert `FileInputStream` ?

`FileInputStream` sert Ã  **lire un fichier sous forme dâ€™octets (bytes)**.

ğŸ“‚ Exemples dâ€™utilisation :

* Fichiers texte
* Images (PNG, JPG)
* PDF
* ZIP
* Fichiers binaires

ğŸš¨ **Important**
`FileInputStream` **ne comprend pas le texte**, il lit seulement des **octets**.

---

## 3ï¸âƒ£ Notion dâ€™octet (Byte)

ğŸ“Œ En Java :

* 1 octet = 8 bits
* type `byte` : de `-128` Ã  `127`

Quand on lit un fichier :

* Java lit **1 octet Ã  la fois**
* Chaque octet est un nombre

---

## 4ï¸âƒ£ CrÃ©er un `FileInputStream`

### Syntaxe de base

```java
FileInputStream fis = new FileInputStream("test.txt");
```

ğŸ“Œ Que fait Java ici ?

1. Ouvre le fichier
2. CrÃ©e un canal de lecture
3. Place le curseur au dÃ©but

ğŸš¨ Si le fichier nâ€™existe pas â†’ **Exception**

---

 5ï¸âƒ£ Lire un octet avec `read()`
  Signature de la mÃ©thode

```java
int read() throws IOException
```

ğŸ“Œ Pourquoi `int` ?

* 0 Ã  255 â†’ octets valides
* `-1` â†’ fin du fichier
  Exemple complet

```java
import java.io.FileInputStream;
import java.io.IOException;

public class Main {
    public static void main(String[] args) {
        try {
            FileInputStream fis = new FileInputStream("test.txt");

            int b;
            while ((b = fis.read()) != -1) {
                System.out.print((char) b);
            }

            fis.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

ğŸ“Œ Ce que fait ce code :

* Lit chaque octet
* Le convertit en caractÃ¨re
* Lâ€™affiche

---

  6ï¸âƒ£ Fin de fichier (`-1`)

Quand `read()` retourne : 
    -1
 
ğŸ‘‰ Cela signifie **fin du fichier**
âŒ Ne jamais faire :
    while (fis.read() != -1) { }

(car tu perds des donnÃ©es)

  7ï¸âƒ£ ProblÃ¨mes courants (dÃ©butants)
âŒ Oublier de fermer le fichier
âŒ Ne pas gÃ©rer les exceptions
âŒ Lire un fichier Unicode avec `FileInputStream`

  8ï¸âƒ£ Mini-exercices (Ã€ FAIRE)
  ğŸ§ª Exercice 1
CrÃ©er un fichier `hello.txt` avec :
```
Bonjour Java
```
Lire et afficher son contenu avec `FileInputStream`.

  ğŸ§ª Exercice 2

Modifier le programme pour :
* Compter le nombre dâ€™octets lus

### ğŸ§ª Exercice 3 (rÃ©flexion)

ğŸ‘‰ Pourquoi Java nâ€™utilise pas directement `char` pour lire un fichier ?
  ğŸ“Œ RÃ©sumÃ© du cours
âœ” `FileInputStream` lit des **octets**
âœ” `read()` retourne `int`
âœ” `-1` = fin de fichier
âœ” Toujours fermer le stream


ğŸ“˜ COURS 2 â€” Exceptions, `try-with-resources` et bonnes pratiques (FileInputStream)

## ğŸ¯ Objectifs du cours 2

Ã€ la fin de ce cours, tu sauras :

* Pourquoi Java **force** les exceptions en I/O
* La diffÃ©rence entre `checked` et `unchecked`
* Pourquoi `try-with-resources` est indispensable
* Les erreurs classiques Ã  Ã©viter

1ï¸âƒ£ Pourquoi les exceptions en I/O ?

Quand tu lis un fichier, Java dÃ©pend de choses **hors du programme** :
    * disque dur
    * permissions
    * fichier supprimÃ©
    * fichier dÃ©jÃ  ouvert
    * erreur systÃ¨me

ğŸ‘‰ Java **ne peut pas garantir** que Ã§a va marcher.
ğŸ“Œ Donc il **tâ€™oblige** Ã  gÃ©rer les erreurs.
---

2ï¸âƒ£ Les exceptions importantes avec `FileInputStream`

    ğŸ”¹ `FileNotFoundException`

```java
new FileInputStream("inexistant.txt");
```
ğŸ“Œ Causes :
    * fichier inexistant
    * mauvais chemin
    * pas de permission
---

    ğŸ”¹ `IOException`

ğŸ“Œ Exception gÃ©nÃ©rale I/O
ğŸ‘‰ Parent de presque toutes les erreurs de lecture

```java
catch (IOException e)
```
âœ” Bonne pratique : attraper **IOException**, pas `Exception`
---

3ï¸âƒ£ Checked vs Unchecked (fondamental)

 âœ” Checked Exception
    * Doit Ãªtre gÃ©rÃ©e
    * VÃ©rifiÃ©e Ã  la compilation

Exemple :

```java
IOException
```

 âŒ Unchecked Exception
    * Optionnelle
    * Erreur de logique

Exemples :

```java
NullPointerException
ArrayIndexOutOfBoundsException
```

ğŸ“Œ I/O = **toujours checked**

---

4ï¸âƒ£ Mauvaise pratique : `catch (Exception e)`

âŒ

```java
catch (Exception e) { }
```

Pourquoi câ€™est mauvais 
    * Cache les bugs
    * Rend le code flou
    * Mauvais en Ã©quipe

âœ” Ã€ faire :

```java
catch (IOException e)
```


5ï¸âƒ£ ProblÃ¨me MAJEUR : fermeture des ressources

    âŒ Ancienne faÃ§on (dangereuse)

```java
FileInputStream fis = new FileInputStream("f.txt");
// lecture
fis.close();
```

ğŸ’¥ Si une exception survient â†’ `close()` jamais appelÃ©
 

6ï¸âƒ£ âœ… Solution officielle : `try-with-resources`

```java
try (FileInputStream fis = new FileInputStream("f.txt")) {
    // lecture
}
```

ğŸ“Œ Java appelle automatiquement :
```java
fis.close();
```
mÃªme sâ€™il y a une exception.

7ï¸âƒ£ Pourquoi Ã§a marche ?

`FileInputStream` implÃ©mente :
```java
AutoCloseable
```

ğŸ‘‰ Toutes les ressources I/O modernes doivent lâ€™implÃ©menter.

8ï¸âƒ£ Exemple COMPLET propre (cours 2)

```java
try (FileInputStream fis = new FileInputStream("fichier.txt")) {
    int b;
    while ((b = fis.read()) != -1) {
        System.out.print((char) b);
    }
} catch (IOException e) {
    System.err.println("Erreur de lecture du fichier");
    e.printStackTrace();
}
```

âœ” lisible
âœ” sÃ»r
âœ” pro

9ï¸âƒ£ Erreurs frÃ©quentes (Ã  graver ğŸ§ )
    âŒ Oublier `try-with-resources`
    âŒ Attraper `Exception`
    âŒ Supposer que le fichier existe
    âŒ MÃ©langer chemins absolus / relatifs
    âŒ Ignorer lâ€™exception

 ğŸ§ª Mini-exercices â€“ COURS 2

Exercice 1
    Supprimer le fichier et observer lâ€™exception levÃ©e.
 Exercice 2
    Afficher un message personnalisÃ© :

```text
Fichier introuvable
```
Exercice 3 (rÃ©flexion)

ğŸ‘‰ Pourquoi Java **oblige** Ã  gÃ©rer `IOException`, mais pas `NullPointerException` ?

## ğŸ“Œ RÃ©sumÃ© COURS 2

âœ” I/O = opÃ©rations risquÃ©es
âœ” Exceptions obligatoires
âœ” `try-with-resources` = norme
âœ” Code lisible et sÃ»r

ğŸ‘‰ Quand tu veux, on enchaÃ®ne avec :

## ğŸ“˜ COURS 3 â€” Lecture avec buffer (`byte[]`) âš¡

*(Performance & bonnes pratiques)*

---

## ğŸ¯ Objectifs du cours 3

Ã€ la fin de ce cours, tu sauras :

* Pourquoi lire **octet par octet est lent**
* Comment lire un fichier avec un **buffer**
* Utiliser correctement `read(byte[])`
* Ã‰crire du code **utilisable en production**

---

## 1ï¸âƒ£ ProblÃ¨me de `read()` simple

### Ce que tu faisais avant

```java
int b;
while ((b = fis.read()) != -1) {
    // ...
}
```

ğŸ“Œ ProblÃ¨me :

* 1 appel systÃ¨me **par octet**
* TrÃ¨s lent pour gros fichiers

ğŸ‘‰ Acceptable pour apprendre, **pas pour un vrai projet**.

---

## 2ï¸âƒ£ Solution : lire par blocs (buffer)

### Principe

On lit **plusieurs octets dâ€™un coup** dans un tableau :

```java
byte[] buffer = new byte[1024]; // 1 KB
```

ğŸ“Œ Le systÃ¨me lit **jusquâ€™Ã  1024 octets** en une seule opÃ©ration.

---

## 3ï¸âƒ£ MÃ©thode clÃ© : `read(byte[])`

### Signature

```java
int read(byte[] buffer) throws IOException
```

ğŸ“Œ Retourne :

* nombre dâ€™octets rÃ©ellement lus
* `-1` â†’ fin du fichier

âš ï¸ Important :

> le buffer nâ€™est pas toujours rempli entiÃ¨rement

---

## 4ï¸âƒ£ Exemple COMPLET (lecture avec buffer)

```java
try (FileInputStream fis = new FileInputStream(fichier.toFile())) {

    byte[] buffer = new byte[1024];
    int bytesRead;
    int total = 0;

    while ((bytesRead = fis.read(buffer)) != -1) {
        total += bytesRead;

        // Affichage (pour fichier texte simple)
        System.out.print(new String(buffer, 0, bytesRead));
    }

    System.out.println("\nTotal octets lus : " + total);

} catch (IOException e) {
    e.printStackTrace();
}
```

---

## 5ï¸âƒ£ Points TRÃˆS importants (exam / pro)

### âš ï¸ Erreur classique âŒ

```java
System.out.print(new String(buffer));
```

âŒ FAUX
ğŸ‘‰ affiche des donnÃ©es parasites

âœ” CORRECT :

```java
new String(buffer, 0, bytesRead)
```

---

## 6ï¸âƒ£ Taille du buffer : combien ?

| Taille        | Usage        |
| ------------- | ------------ |
| 512 B         | ancien       |
| 1024 B (1 KB) | ok           |
| 4096 B (4 KB) | recommandÃ©   |
| 8192 B (8 KB) | trÃ¨s courant |

ğŸ“Œ En gÃ©nÃ©ral :

```java
byte[] buffer = new byte[4096];
```

---

## 7ï¸âƒ£ Comparaison performance (conceptuel)

| MÃ©thode               | Vitesse           |
| --------------------- | ----------------- |
| `read()`              | ğŸ¢ trÃ¨s lent      |
| `read(byte[])`        | ğŸš€ rapide         |
| `BufferedInputStream` | ğŸš€ğŸš€ encore mieux |

---

## 8ï¸âƒ£ Quand utiliser `FileInputStream` + buffer ?

âœ” fichiers binaires
âœ” copie de fichiers
âœ” upload / download
âœ” traitement batch

âŒ pas idÃ©al pour texte Unicode (UTF-8 avancÃ©)

---

## ğŸ§ª Exercices â€” COURS 3

### Exercice 1

Lire un fichier avec un buffer de 4096 octets
â¡ï¸ afficher le contenu
â¡ï¸ afficher la taille totale

---

### Exercice 2

Copier un fichier :

```
source.txt â†’ copie.txt
```

---

### Exercice 3 (rÃ©flexion)

ğŸ‘‰ Pourquoi `read(byte[])` peut retourner un nombre **plus petit que la taille du buffer** ?

---

## ğŸ“Œ RÃ©sumÃ© COURS 3

âœ” lecture par blocs
âœ” Ã©norme gain de performance
âœ” gestion correcte de `bytesRead`
âœ” prÃªt pour des fichiers volumineux

---

ğŸ˜„ parfait â€” **COURS 4**, on y va.
LÃ  on touche Ã  un truc **trÃ¨s important en Java pro** : **`BufferedInputStream`** et **le pattern Decorator**.

---

 ğŸ“˜ COURS 4 â€” `BufferedInputStream` & Decorator Pattern

---

 ğŸ¯ Objectifs du cours 4

Ã€ la fin, tu sauras :
    * Pourquoi `BufferedInputStream` existe
    * Comment lâ€™utiliser correctement
    * Ce quâ€™est le **Decorator Pattern**
    * Pourquoi câ€™est partout en Java I/O

1ï¸âƒ£ ProblÃ¨me Ã  rÃ©soudre (le vrai)

MÃªme avec :

    ```java
    byte[] buffer = new byte[4096];
    fis.read(buffer);
    ```
ğŸ‘‰ chaque appel va quand mÃªme **au systÃ¨me**.
ğŸ“Œ Le disque est lent, les appels systÃ¨me coÃ»tent cher.

---
 2ï¸âƒ£ Solution : `BufferedInputStream`

### RÃ´le

ğŸ‘‰ Ajouter un **tampon interne** entre ton code et le disque.

    ```text
    Disque â†’ [Buffer interne] â†’ Ton programme
    ```

RÃ©sultat :
    * moins dâ€™accÃ¨s disque
    * meilleures performances
    * code plus propre

---
 3ï¸âƒ£ CrÃ©ation dâ€™un `BufferedInputStream`

    ```java
    BufferedInputStream bis =
        new BufferedInputStream(new FileInputStream(fichier.toFile()));
    ```

ğŸ“Œ Tu ne remplaces pas `FileInputStream`
ğŸ“Œ Tu **lâ€™enrobes**

---

4ï¸âƒ£ Exemple COMPLET (lecture PRO)

    ```java
    try (
        BufferedInputStream bis =
            new BufferedInputStream(
                new FileInputStream(fichier.toFile())
            )
    ) {
        byte[] buffer = new byte[4096];
        int bytesRead;
        int total = 0;

        while ((bytesRead = bis.read(buffer)) != -1) {
            total += bytesRead;
            System.out.print(new String(buffer, 0, bytesRead));
        }

        System.out.println("\nTotal octets : " + total);

    } catch (IOException e) {
        e.printStackTrace();
    }
    ```

---
5ï¸âƒ£ DiffÃ©rence clÃ© avec buffer manuel

| Buffer manuel  | BufferedInputStream |
| -------------- | ------------------- |
| GÃ©rÃ© par toi   | GÃ©rÃ© par Java       |
| Niveau bas     | Niveau plus haut    |
| Toujours utile | RecommandÃ©          |

ğŸ“Œ En pratique : **on combine les deux**.

---

6ï¸âƒ£ Le Decorator Pattern (important ğŸ’¡)

### DÃ©finition simple
ğŸ‘‰ Ajouter des fonctionnalitÃ©s **sans modifier la classe originale**.

### Exemple visuel

    ```java
    InputStream in =
        new BufferedInputStream(
            new FileInputStream("fichier.txt")
        );
    ```
ğŸ“Œ Chaque couche **ajoute un comportement**.

---
 7ï¸âƒ£ Autres dÃ©corateurs cÃ©lÃ¨bres

| Classe              | RÃ´le                 |
| ------------------- | -------------------- |
| `DataInputStream`   | Lire types primitifs |
| `ObjectInputStream` | Lire objets          |
| `GZIPInputStream`   | DÃ©compression        |
| `CipherInputStream` | Chiffrement          |

ğŸ‘‰ Tous utilisent le **mÃªme principe**

8ï¸âƒ£ Quand utiliser `BufferedInputStream` ?

    âœ” presque toujours avec fichiers
    âœ” fichiers volumineux
    âœ” performance critique
âŒ inutile pour trÃ¨s petits fichiers

---

## ğŸ§ª Exercices â€” COURS 4
### Exercice 1
Lire un fichier avec :

```java
BufferedInputStream + buffer 8192
```

---
### Exercice 2
Comparer :
    * `FileInputStream` seul
    * `FileInputStream + buffer`
    * `BufferedInputStream + buffer`

---

### Exercice 3 (rÃ©flexion)
ğŸ‘‰ Pourquoi Java nâ€™a **pas** intÃ©grÃ© le buffer directement dans `FileInputStream` ?

---

## ğŸ“Œ RÃ©sumÃ© COURS 4

âœ” buffering automatique
âœ” Decorator Pattern compris
âœ” architecture I/O Java
âœ” code production-ready

---

ğŸ˜„ parfait â€” **COURS 5**, on y va.
Attache la ceinture : câ€™est **le cours le plus important pour le texte en Java**.

---

# ğŸ“˜ COURS 5 â€” Texte, encodage et UTF-8

*(Le piÃ¨ge nÂ°1 en Java I/O)*

---
## ğŸ¯ Objectifs du cours 5

Ã€ la fin, tu sauras :
    * Pourquoi ton code peut afficher des caractÃ¨res cassÃ©s
    * La diffÃ©rence **octets vs caractÃ¨res**
    * Ce quâ€™est un **encodage**
    * Pourquoi `FileInputStream` nâ€™est **pas fait pour le texte**
    * Comment lire du texte **correctement en UTF-8**
---

1ï¸âƒ£ Le problÃ¨me fondamental
Ton code actuel :

    ```java
    new String(buffer, 0, b)
    ```
ğŸ‘‰ Tu fais :
```
octets (byte[]) â†’ caractÃ¨res (String)
```
ğŸ“Œ MAIS **sans dire comment convertir**.

Java choisit alors :

> lâ€™encodage par dÃ©faut du systÃ¨me

ğŸ’¥ RÃ©sultat :

    * Windows â†’ CP1252
    * Linux â†’ UTF-8
    * Serveur â†’ autreâ€¦

ğŸ‘‰ Code **non portable**.
---

 2ï¸âƒ£ Exemple du bug (classique)

### Fichier `textes.txt`

    ```
    Bonjour Java
    Ã© Ã¨ Ã  Ã§
    ```

### RÃ©sultat possible
    ```
    Bonjour Java
    ï¿½ ï¿½ ï¿½ ï¿½
    ```

ğŸ‘‰ Le fichier est bon
ğŸ‘‰ Le code est mauvais
---

3ï¸âƒ£ Pourquoi Ã§a casse ? (clÃ© ğŸ”‘)
### UTF-8 â‰  1 octet = 1 caractÃ¨re

| CaractÃ¨re | Octets UTF-8 |
| --------- | ------------ |
| A         | 1            |
| Ã©         | 2            |
| â‚¬         | 3            |
| ğŸ˜Š        | 4            |

ğŸ‘‰ Ton buffer peut **couper un caractÃ¨re en plein milieu**.
---

4ï¸âƒ£ RÃ¨gle dâ€™or (Ã  graver)

> âŒ `FileInputStream` = **binaire**
> âœ… `Reader` = **texte**
---

5ï¸âƒ£ La BONNE solution : `InputStreamReader`
### Pourquoi ?
ğŸ‘‰ Il sait :
    * gÃ©rer UTF-8
    * reconstituer les caractÃ¨res
    * gÃ©rer les coupures de buffer
---
6ï¸âƒ£ Lecture correcte dâ€™un fichier texte (UTF-8)

    ```java
    Path fichier = Path.of("C:\\Users\\toavina\\Desktop\\java\\textes.txt");

    try (
        InputStreamReader reader =
            new InputStreamReader(
                new FileInputStream(fichier.toFile()),
                StandardCharsets.UTF_8
            )
    ) {
        char[] buffer = new char[4096];
        int charsRead;

        while ((charsRead = reader.read(buffer)) != -1) {
            System.out.print(new String(buffer, 0, charsRead));
        }

    } catch (IOException e) {
        e.printStackTrace();
    }
    ```
---

 7ï¸âƒ£ Encore mieux : `BufferedReader`

    ```java
    try (
        BufferedReader br =
            Files.newBufferedReader(fichier, StandardCharsets.UTF_8)
    ) {
        String line;
        while ((line = br.readLine()) != null) {
            System.out.println(line);
        }
    }
    ```
âœ” simple
âœ” lisible
âœ” UTF-8 safe
âœ” standard pro
---

8ï¸âƒ£ Comparaison des approches

| API                     | Usage              |
| ----------------------- | ------------------ |
| FileInputStream         | binaire            |
| BufferedInputStream     | binaire performant |
| InputStreamReader       | binaire â†’ texte    |
| BufferedReader          | texte              |
| Files.newBufferedReader | texte moderne      |
---

 ğŸ§ª Exercices â€” COURS 5

Exercice 1
CrÃ©er un fichier avec :

    ```
    Ã© Ã¨ Ã  Ã§ ğŸ˜Š
    ```
Lire avec :
    * ton ancien code âŒ
    * `BufferedReader` âœ…
---
 Exercice 2
Pourquoi `BufferedReader.readLine()` ne casse jamais les caractÃ¨res UTF-8 ?
---

 Exercice 3 (entretien)
ğŸ‘‰ Quand faut-il **absolument Ã©viter** `FileInputStream` ?
---

 ğŸ“Œ RÃ©sumÃ© COURS 5

âœ” octets â‰  caractÃ¨res
âœ” encodage explicite obligatoire
âœ” UTF-8 maÃ®trisÃ©
âœ” API correcte pour le texte

---
ğŸ‰ **Ã€ ce stade, tu es dÃ©jÃ  au-dessus de beaucoup de dÃ©veloppeurs Java.**
ğŸ˜„ parfait â€” **COURS 6** ğŸš€
LÃ  on entre dans **le Java moderne**, celui utilisÃ© **en entreprise**, surtout cÃ´tÃ© backend.

---

ğŸ“˜ COURS 6 â€” Java NIO / NIO.2
*(Files, Path, Channels â€” niveau pro)*

ğŸ¯ Objectifs du cours 6

Ã€ la fin, tu sauras :
    * Pourquoi Java a crÃ©Ã© **NIO**
    * Utiliser `Path` et `Files` correctement
    * Lire des fichiers en **une ligne**
    * Comprendre les **Channels**
    * Savoir quand **ne pas** utiliser `FileInputStream`
---

 1ï¸âƒ£ Pourquoi NIO existe ?

Les anciens I/O (`java.io`) :
    * bloquants
    * peu flexibles
    * difficiles Ã  scaler

ğŸ‘‰ **NIO (New I/O)** apporte :
    * meilleures performances
    * API moderne
    * meilleure gestion des gros fichiers
    * meilleure intÃ©gration serveur
---

2ï¸âƒ£ `Path` : remplaÃ§ant de `File`
âŒ Ancien :
    ```java
    File f = new File("test.txt");
    ```
âœ… Moderne :
    ```java
    Path p = Path.of("test.txt");
    ```

âœ” immuable
âœ” portable
âœ” puissant
---

3ï¸âƒ£ Lire un fichier simplement (NIO)

ğŸ”¹ Lire tout le fichier
    ```java
    String contenu = Files.readString(fichier, StandardCharsets.UTF_8);
    System.out.println(contenu);
    ```
âš ï¸ Ã€ Ã©viter pour gros fichiers
---

### ğŸ”¹ Lire toutes les lignes
```java
List<String> lignes =
    Files.readAllLines(fichier, StandardCharsets.UTF_8);
```

 4ï¸âƒ£ Lire un fichier comme un Stream
    ```java
    try (Stream<String> lignes = Files.lines(fichier, StandardCharsets.UTF_8)) {
        lignes.forEach(System.out::println);
    }
    ```
âœ” paresseux
âœ” mÃ©moire maÃ®trisÃ©e
âœ” trÃ¨s utilisÃ©
---
## 5ï¸âƒ£ Channels â€” niveau avancÃ©
### Concept
ğŸ‘‰ Canal = lecture directe vers buffers

    ```java
    try (FileChannel channel = FileChannel.open(fichier)) {
        ByteBuffer buffer = ByteBuffer.allocate(4096);
        while (channel.read(buffer) > 0) {
            buffer.flip();
            // traitement
            buffer.clear();
        }
    }
    ```
ğŸ“Œ UtilisÃ© pour :
    * gros fichiers
    * haute performance
    * serveurs
---
6ï¸âƒ£ Comparaison des APIs

| Besoin             | API              |
| ------------------ | ---------------- |
| Texte simple       | BufferedReader   |
| Fichier petit      | Files.readString |
| Gros fichier texte | Files.lines      |
| Binaire            | FileChannel      |
| TrÃ¨s haute perf    | NIO              |
---

7ï¸âƒ£ Quand Ã©viter `FileInputStream` ?
    âŒ Lecture texte
    âŒ Encodage
    âŒ Gros fichiers
    âŒ Code moderne

âœ” Utilisable encore pour :
    * fichiers binaires simples
    * apprentissage
---

ğŸ§ª Exercices â€” COURS 6

Exercice 1
Lire un fichier avec :

    ```java
    Files.lines(...)
    ```
--

Exercice 2
Comparer :
    * `BufferedReader`
    * `Files.lines`
---
### Exercice 3 (rÃ©flexion)
ğŸ‘‰ Pourquoi `Files.lines()` doit Ãªtre fermÃ© ?
---
## ğŸ“Œ RÃ©sumÃ© COURS 6
âœ” NIO moderne
âœ” API simples
âœ” haute performance
âœ” prÃªt pour backend
---
ğŸ˜„ excellent choix â€” **COURS 7**.
LÃ , on quitte le â€œcoursâ€ pour entrer dans **la vraie vie de dÃ©veloppeur Java**.

---

# ğŸ“˜ COURS 7 â€” Cas rÃ©els professionnels (Java I/O)

---

## ğŸ¯ Objectifs du cours 7

Ã€ la fin, tu sauras :

* Copier des fichiers correctement
* GÃ©rer des **gros fichiers**
* ImplÃ©menter un **upload / download**
* Ã‰viter les erreurs classiques en production
* Ã‰crire du code **maintenable**

---

## ğŸ§© CAS 1 â€” Copier un fichier (bonne pratique)

### âŒ Mauvaise faÃ§on

```java
Files.readAllBytes(source);
```

ğŸ’¥ Explose la mÃ©moire sur gros fichiers

---

### âœ… Bonne faÃ§on (NIO, bufferisÃ©)

```java
Path source = Path.of("source.txt");
Path destination = Path.of("copie.txt");

try (InputStream in = Files.newInputStream(source);
     OutputStream out = Files.newOutputStream(destination)) {

    byte[] buffer = new byte[8192];
    int bytesRead;

    while ((bytesRead = in.read(buffer)) != -1) {
        out.write(buffer, 0, bytesRead);
    }
}
```

---

## ğŸ§© CAS 2 â€” Copier encore plus simple (API moderne)

```java
Files.copy(source, destination, StandardCopyOption.REPLACE_EXISTING);
```

âœ” lisible
âœ” sÃ»r
âœ” utilisÃ© partout

---

## ğŸ§© CAS 3 â€” Lecture de gros fichier texte

```java
try (Stream<String> lignes = Files.lines(fichier, StandardCharsets.UTF_8)) {
    lignes.forEach(line -> {
        // traitement
    });
}
```

âœ” mÃ©moire constante
âœ” scalable

---

## ğŸ§© CAS 4 â€” Upload de fichier (backend)

```java
public void upload(InputStream input, Path destination) throws IOException {
    Files.copy(input, destination, StandardCopyOption.REPLACE_EXISTING);
}
```

ğŸ“Œ Typique Spring Boot :

```java
MultipartFile file;
file.getInputStream();
```

---

## ğŸ§© CAS 5 â€” Download de fichier

```java
public InputStream download(Path fichier) throws IOException {
    return Files.newInputStream(fichier);
}
```

---

## âš ï¸ Erreurs classiques en production

âŒ lire tout en mÃ©moire
âŒ oublier lâ€™encodage
âŒ oublier de fermer les streams
âŒ `catch(Exception e)`
âŒ chemins hardcodÃ©s

---

## ğŸ¯ Question dâ€™entretien (trÃ¨s frÃ©quente)

> â“ Comment copier un fichier de 10 Go sans saturer la mÃ©moire ?

ğŸ‘‰ RÃ©ponse :

* stream + buffer
* ou `Files.copy()`

---

## ğŸ“Œ RÃ©sumÃ© COURS 7

âœ” cas rÃ©els
âœ” code industrie
âœ” scalable
âœ” prÃªt backend

---

## ğŸ Et maintenant ?

ğŸ‘‰ **HonnÃªtement** : tu as atteint le **niveau professionnel solide** en Java I/O.

Il reste deux options (bonus ğŸ”¥) :

### ğŸŸ£ COURS 8 â€” Bonnes pratiques industrie + piÃ¨ges dâ€™entretien

### ğŸŸ¢ Mini-projet final (upload / traitement fichier)

ğŸ˜„
Dis-moi : **8 ou mini-projet ?**




